#!/usr/bin/env bash

function set_colors
{
    bold=$'\e[1m'
    reset=$'\e[0m'
    uline=$'\e[4m'

    for i in {0..7}; do
        f+=("$(printf "%b" "\\e[3${i}m")")
        b+=("$(printf "%b" "\\e[4${i}m")")
        fb+=("${f[$i]}${bold}")
        bb+=("${b[$i]}${bold}")
    done

    tick="[${f[2]}✔${reset}]"
    cross="[${f[1]}✗${reset}]"
}

function unset_colors
{
    unset bold reset uline
    unset {f,b}{,b}

    tick="[✔]"
    cross="[✗]"
}

function get_full_path
(
    target="$1"

    if [[ -f "${target}" ]]; then
        filename="${target##*/}"
        [[ "${filename}" == "${target}" ]] && \
            target="./${target}"
        target="${target%/*}"
        cd "${target}" || exit
        full_path="${PWD}"
    elif [[ -d "${target}" ]]; then
        cd "${target}" || exit
        full_path="${PWD}"
    fi

    printf "%s" "${full_path}"
)

function check_app
{
    ((BASH_VERSINFO[0] < 4 || BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 4)) && {
        printf "%s\\n" "Bash 4.4+ required"
        _exit="true"
    }

    app_list=("ffmpeg")

    for i in "${app_list[@]}"; do
        ! type -p ${i} > /dev/null && \
            missing+=("${i}")
    done

    ((${#missing[@]} > 0)) && {
        _exit="${exit:=true}"
        for i in "${missing[@]}"; do
            printf "%s\\n" "${i} is not installed"
        done
    }

    [[ "${_exit}" == "true" ]] && {
        printf "%s\\n" "Exiting..."
        exit 1
    }
}

function check_dirs
{
    if [[ ! "${output_dir}" ]]; then
        input_dir="$(get_full_path "${input_dir%/}")"
        output_dir="${PWD}/out"
    else
        input_dir="$(get_full_path "${input_dir%/}")"
        output_dir="$(get_full_path "${output_dir%/}")"
    fi

    [[ ! -d "${input_dir}" ]] && {
        print_usage
        printf "%s\\n\\n" "\"${input_dir}\" is not a valid input directory"
        exit 1
    }

    [[ ! -d "${output_dir}" ]] && {
        printf "%s\\n" "\"${output_dir}\" is not a valid output directory"
        printf "%s\\n" "Do you want to create it? [Y/n] "
        read -r a
        if [[ "${a}" =~ ^[Yy]$ ]]; then
            mkdir -p "${output_dir}"
        else
            printf "%s\\n" "Exiting..."
            exit 1
        fi
    }
}

function print_usage
{
    printf "%s\\n" "
Usage:  ./mp3pls.sh --option --option VALUE

    Options:

    [-i|--input \"${uline}${bold}DIRECTORY${reset}\"]        Input path for files
    [-o|--output \"${uline}${bold}DIRECTORY${reset}\"]       Output path for converted files
    [--ffmpeg-flags \"${uline}${bold}FLAGS${reset}\"]        Set flags for ffmpeg
    [--no-colors]                   Disable color output
    [-h|--help]                     Print this message
"
}

function get_args
{
    [[ ! "$1" ]] && {
        print_usage
        printf "%s\\n\\n" "No arguments passed"
        exit 1
    }


    while (($# > 0)); do
        case "$1" in
            "-i"|"--input")     input_dir="$2"; shift ;;
            "-o"|"--output")    output_dir="$2"; shift ;;
            "--ffmpeg-flags")   ffmpeg_flags="$2"; shift ;;
            "--no-colors")      unset_colors ;;
            "-h"|"--help")      print_usage; exit 0 ;;
        esac
        shift
    done
}

function get_file_list
{
    shopt -s globstar
    for file in "${input_dir}"/**/*; do
        [[ ! -d "${file}" ]] && {
            local file_ext="${file##*.}"
            [[ "${file_ext,,}" =~ ^(wav|flac)$ ]] && \
                file_list+=("${file}")
        }
    done
    shopt -u globstar
}

function process_files
(
    function _process
    (
        trap "exit 1" INT
        ffmpeg_flags="${ffmpeg_flags:=-q:a 0 -loglevel fatal}"
        for file in "$@"; do
            source_dir="${file%/*}"
            source_dir="${source_dir#${input_dir}}"
            source_file="${file##*/}"
            source_filename="${source_file%.*}"
            output_source_dir="${output_dir}${source_dir}"
            output_filename="${output_source_dir}/${source_filename}.mp3"
            display="${file#${input_dir}}"
            display="${display#/}"

            mkdir -p "${output_source_dir}"

            printf "%s\\r" "${display} ..."
            if ffmpeg -i "${file}" ${ffmpeg_flags} "${output_filename}"; then
                printf "%s\\n" "${tick} ${display%.*}.mp3"
            else
                printf "%s\\n" "${cross} ${display%.*}.mp3"
            fi
        done
    )

    _process "${file_list[@]}"
)

function display_seconds
(
    secs="${SECONDS}"
    hours="$((secs / 60 / 60 % 24))"
    mins="$((secs / 60 % 60))"
    secs="$((secs - ((mins * 60) + (hours * 3600))))"

    hours+="h "
    mins+="m "
    secs+="s"

    ((${hours/h*} == 0)) && unset hours
    ((${mins/m*} == 0)) && unset mins

    printf "%s\\n" "Converted ${#file_list[@]} files in ${hours:-}${mins:-}${secs// }"
)

function main
{
    set_colors
    get_args "$@"
    check_app
    check_dirs

    get_file_list
    process_files
    display_seconds
}

main "$@"
